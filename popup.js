class ZimanTranslator {
    constructor() {
        this.initializeElements();
        this.bindEvents();
        this.loadSettings();
    }

    initializeElements() {
        this.sourceLang = document.getElementById('sourceLang');
        this.targetLang = document.getElementById('targetLang');
        this.tone = document.getElementById('tone');
        this.sourceText = document.getElementById('sourceText');
        this.resultText = document.getElementById('resultText');
        this.translateBtn = document.getElementById('translateBtn');
        this.swapBtn = document.getElementById('swapBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.pasteBtn = document.getElementById('pasteBtn');
        this.copyBtn = document.getElementById('copyBtn');
        this.speakBtn = document.getElementById('speakBtn');
        this.pageTranslateBtn = document.getElementById('pageTranslateBtn');
        this.selectionBtn = document.getElementById('selectionBtn');
        this.phonetic = document.getElementById('phonetic');
        this.apiKeyInput = document.getElementById('apiKey');
        this.saveApiKeyBtn = document.getElementById('saveApiKey');
        this.testApiKeyBtn = document.getElementById('testApiKey');
    }

    bindEvents() {
        this.translateBtn.addEventListener('click', () => this.translate());
        this.swapBtn.addEventListener('click', () => this.swapLanguages());
        this.clearBtn.addEventListener('click', () => this.clearText());
        this.pasteBtn.addEventListener('click', () => this.pasteText());
        this.copyBtn.addEventListener('click', () => this.copyResult());
        this.speakBtn.addEventListener('click', () => this.speakText());
        this.pageTranslateBtn.addEventListener('click', () => this.translatePage());
        this.selectionBtn.addEventListener('click', () => this.translateSelection());
        this.saveApiKeyBtn.addEventListener('click', () => this.saveApiKey());
        this.testApiKeyBtn.addEventListener('click', () => this.testApiKey());
        
        // Auto-save settings
        this.sourceLang.addEventListener('change', () => this.saveSettings());
        this.targetLang.addEventListener('change', () => this.saveSettings());
        this.tone.addEventListener('change', () => this.saveSettings());
    }

    async loadSettings() {
        try {
            const result = await chrome.storage.sync.get(['sourceLang', 'targetLang', 'tone', 'apiKey']);
            if (result.sourceLang) this.sourceLang.value = result.sourceLang;
            if (result.targetLang) this.targetLang.value = result.targetLang;
            if (result.tone) this.tone.value = result.tone;
            if (result.apiKey) this.apiKeyInput.value = result.apiKey;
        } catch (error) {
            console.error('Error loading settings:', error);
        }
    }

    async saveSettings() {
        try {
            await chrome.storage.sync.set({
                sourceLang: this.sourceLang.value,
                targetLang: this.targetLang.value,
                tone: this.tone.value
            });
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }

    async saveApiKey() {
        try {
            const apiKey = this.apiKeyInput.value.trim();
            if (apiKey) {
                await chrome.storage.sync.set({ apiKey: apiKey });
                this.showResult('‚úÖ API Key saved successfully!');
                this.saveApiKeyBtn.textContent = '‚úÖ Saved';
                setTimeout(() => {
                    this.saveApiKeyBtn.textContent = 'üíæ Save API Key';
                }, 2000);
            } else {
                this.showResult('‚ùå Please enter a valid API key.');
            }
        } catch (error) {
            console.error('Error saving API key:', error);
            this.showResult('‚ùå Error saving API key.');
        }
    }

    async testApiKey() {
        try {
            const apiKey = this.apiKeyInput.value.trim();
            if (!apiKey) {
                this.showResult('‚ùå Please enter an API key first.');
                return;
            }

            this.testApiKeyBtn.textContent = 'üß™ Testing...';
            this.testApiKeyBtn.disabled = true;

            // Test with AIML API
            if (window.AIMLAPI) {
                const aimlAPI = new window.AIMLAPI();
                aimlAPI.apiKey = apiKey;
                
                try {
                    const testResult = await aimlAPI.testAPIKey();
                    if (testResult.valid) {
                        this.showResult('‚úÖ API Key is valid! You can now use all AI chatbots.');
                        this.testApiKeyBtn.textContent = '‚úÖ Connected';
                    } else {
                        this.showResult(`‚ùå API Key test failed: ${testResult.message}`);
                        this.testApiKeyBtn.textContent = '‚ùå Failed';
                    }
                } catch (error) {
                    this.showResult(`‚ùå API test error: ${error.message}`);
                    this.testApiKeyBtn.textContent = '‚ùå Error';
                }
            } else {
                this.showResult('‚ùå AIML API not available. Please refresh the page.');
                this.testApiKeyBtn.textContent = '‚ùå Unavailable';
            }

            setTimeout(() => {
                this.testApiKeyBtn.textContent = 'üß™ Test Connection';
                this.testApiKeyBtn.disabled = false;
            }, 3000);

        } catch (error) {
            console.error('Error testing API key:', error);
            this.showResult('‚ùå Error testing API key.');
            this.testApiKeyBtn.textContent = 'üß™ Test Connection';
            this.testApiKeyBtn.disabled = false;
        }
    }

    async translate() {
        const text = this.sourceText.value.trim();
        if (!text) {
            this.showResult('Please enter text to translate.');
            return;
        }

        this.translateBtn.disabled = true;
        this.translateBtn.innerHTML = '<span class="spinner"></span> Translating...';
        this.translateBtn.classList.add('pulse');
        
        try {
            const translation = await this.performTranslation(text);
            this.showResult(translation);
        } catch (error) {
            this.showResult(`Translation error: ${error.message}`);
        } finally {
            this.translateBtn.disabled = false;
            this.translateBtn.textContent = 'Translate';
            this.translateBtn.classList.remove('pulse');
        }
    }

    async performTranslation(text) {
        const sourceLang = this.sourceLang.value;
        const targetLang = this.targetLang.value;
        const tone = this.tone.value;
        const includePhonetic = this.phonetic.checked;

        // Show status to user
        this.showResult('üîÑ Translating with AI...');

        try {
            // First try to use AIML API (AI-powered translation)
            if (sourceLang !== 'auto' && window.AIMLAPI) {
                const translation = await this.translateWithAIML(text, sourceLang, targetLang, tone);
                if (translation) {
                    let result = translation;
                    if (includePhonetic && sourceLang.startsWith('ku')) {
                        result += `\n\nPhonetic: ${this.getPhonetic(text)}`;
                    }
                    return result;
                } else {
                    console.log('AIML API returned no translation, trying Weblate...');
                    this.showResult('üîÑ AI translation failed, trying professional translation...');
                }
            }
        } catch (error) {
            console.warn('AIML API failed, trying Weblate:', error);
            this.showResult('üîÑ AI translation failed, trying professional translation...');
        }

        try {
            // Fallback to Weblate API
            if (sourceLang !== 'auto') {
                const translation = await this.translateWithWeblate(text, sourceLang, targetLang, tone);
                if (translation) {
                    let result = translation;
                    if (includePhonetic && sourceLang.startsWith('ku')) {
                        result += `\n\nPhonetic: ${this.getPhonetic(text)}`;
                    }
                    return result;
                }
            }
        } catch (error) {
            console.warn('Weblate API failed, using fallback:', error);
            this.showResult('üîÑ Professional translation failed, using local translation...');
        }

        // Final fallback to enhanced mock translations
        this.showResult('üîÑ Using local translation...');
        const translation = await this.translateWithFallback(text, sourceLang, targetLang, tone);
        let result = translation;
        
        if (includePhonetic && sourceLang.startsWith('ku')) {
            result += `\n\nPhonetic: ${this.getPhonetic(text)}`;
        }
        
        return result;
    }

    async translateWithAIML(text, sourceLang, targetLang, tone) {
        try {
            if (!window.AIMLAPI) {
                throw new Error('AIML API not available');
            }

            const aimlAPI = new window.AIMLAPI();
            
            // Use personal API key if available
            const apiKey = this.apiKeyInput.value.trim();
            if (apiKey) {
                aimlAPI.apiKey = apiKey;
                console.log('Using personal API key for AI translation');
            } else {
                console.log('Using default API key for AI translation');
            }
            
            // First check if API key is valid
            const keyTest = await aimlAPI.testAPIKey();
            if (!keyTest.valid) {
                console.warn('AIML API key validation failed:', keyTest.message);
                return null; // Fall back to other methods
            }
            
            const translation = await aimlAPI.translateText(text, sourceLang, targetLang, tone);
            
            if (translation && !translation.includes('Translation failed')) {
                return translation;
            }
            
            return null;
        } catch (error) {
            console.error('AIML API error:', error);
            
            // Provide user-friendly error message
            if (error.message.includes('API access denied')) {
                console.warn('AIML API access denied - falling back to Weblate');
            }
            
            return null;
        }
    }

    async translateWithWeblate(text, sourceLang, targetLang, tone) {
        try {
            // Use background script to avoid CORS issues
            if (chrome && chrome.runtime) {
                const response = await chrome.runtime.sendMessage({
                    action: 'callWeblateAPI',
                    text: text,
                    sourceLang: sourceLang,
                    targetLang: targetLang,
                    tone: tone
                });
                
                if (response && response.success) {
                    return response.translation;
                }
            }
            
            return null;
        } catch (error) {
            console.error('Weblate API error:', error);
            return null;
        }
    }

    async translateWithFallback(text, sourceLang, targetLang, tone) {
        // Enhanced fallback translations
        const translations = {
            'ku-sorani-en': {
                'ÿ≥⁄µÿßŸà': 'Hello',
                '⁄Ü€ÜŸÜ€å': 'How are you?',
                'ÿ≥⁄µÿßŸàÿå ⁄Ü€ÜŸÜ€åÿü': 'Hello, how are you?',
                'ÿ≥ŸàŸæÿßÿ≥': 'Thank you',
                'ÿ®€ï⁄ï€éÿ≤': 'Sir/Madam',
                'ÿ®€ï€åÿßŸÜ€å ÿ®ÿßÿ¥': 'Good morning',
                'ÿ¥€ïŸà€å ÿ®ÿßÿ¥': 'Good night',
                'ÿÆŸàÿßÿ™ ŸÑ€ï⁄Ø€ï⁄µ': 'Goodbye',
                'ŸÖŸÜ ŸÜÿßŸà€å ŸÖŸÜ ŸÜÿßÿ≥€ïÿ±€ï': 'My name is Naser',
                '⁄Ü€ÜŸÜ ÿØ€ï⁄Ü€åÿ™': 'How are you doing?',
                'ÿ≤€Üÿ± ÿ®ÿßÿ¥ ÿ®ŸàŸà': 'It was very good',
                'ÿ®€Ü €åÿßÿ±ŸÖ€ïÿ™€åÿ™': 'For your help'
            },
            'en-ku-sorani': {
                'Hello': 'ÿ≥⁄µÿßŸà',
                'How are you?': '⁄Ü€ÜŸÜ€åÿü',
                'Thank you': 'ÿ≥ŸàŸæÿßÿ≥',
                'Good morning': 'ÿ®€ï€åÿßŸÜ€å ÿ®ÿßÿ¥',
                'Good night': 'ÿ¥€ïŸà€å ÿ®ÿßÿ¥',
                'Goodbye': 'ÿÆŸàÿßÿ™ ŸÑ€ï⁄Ø€ï⁄µ',
                'My name is': 'ŸÖŸÜ ŸÜÿßŸà€å ŸÖŸÜ',
                'How are you doing?': '⁄Ü€ÜŸÜ ÿØ€ï⁄Ü€åÿ™ÿü',
                'It was very good': 'ÿ≤€Üÿ± ÿ®ÿßÿ¥ ÿ®ŸàŸà',
                'For your help': 'ÿ®€Ü €åÿßÿ±ŸÖ€ïÿ™€åÿ™'
            },
            'ku-kurmanji-en': {
                'Silav': 'Hello',
                'Tu √ßawa y√Æ?': 'How are you?',
                'Silav, tu √ßawa y√Æ?': 'Hello, how are you?',
                'Spas': 'Thank you',
                'Ez Naser im': 'I am Naser'
            },
            'en-ku-kurmanji': {
                'Hello': 'Silav',
                'How are you?': 'Tu √ßawa y√Æ?',
                'Thank you': 'Spas',
                'I am Naser': 'Ez Naser im'
            },
            'fa-en': {
                'ÿ≥ŸÑÿßŸÖ': 'Hello',
                '⁄Üÿ∑Ÿàÿ±€å': 'How are you?',
                'ÿßÿ≥ŸÖ ŸÖŸÜ ŸÜÿßÿµÿ± ÿßÿ≥ÿ™': 'My name is Naser',
                'ŸÖŸÖŸÜŸàŸÜ': 'Thank you',
                'ÿÆÿØÿßÿ≠ÿßŸÅÿ∏': 'Goodbye'
            },
            'en-fa': {
                'Hello': 'ÿ≥ŸÑÿßŸÖ',
                'How are you?': '⁄Üÿ∑Ÿàÿ±€åÿü',
                'My name is Naser': 'ÿßÿ≥ŸÖ ŸÖŸÜ ŸÜÿßÿµÿ± ÿßÿ≥ÿ™',
                'Thank you': 'ŸÖŸÖŸÜŸàŸÜ',
                'Goodbye': 'ÿÆÿØÿßÿ≠ÿßŸÅÿ∏'
            }
        };

        const key = `${sourceLang}-${targetLang}`;
        const translation = translations[key]?.[text];
        
        if (translation) {
            return translation;
        }

        // If no direct translation, try to find similar text
        for (const [key, langTranslations] of Object.entries(translations)) {
            if (key === `${sourceLang}-${targetLang}`) {
                for (const [source, target] of Object.entries(langTranslations)) {
                    if (text.toLowerCase().includes(source.toLowerCase()) || 
                        source.toLowerCase().includes(text.toLowerCase())) {
                        return target;
                    }
                }
            }
        }

        // If still no translation, return a formatted response
        return `[${text}] translated to ${targetLang}`;
    }

    getPhonetic(kurdishText) {
        // Enhanced phonetic mapping for Kurdish
        const phoneticMap = {
            'ÿ≥⁄µÿßŸà': 'slaaw',
            '⁄Ü€ÜŸÜ€å': 'choni',
            'ÿ≥⁄µÿßŸàÿå ⁄Ü€ÜŸÜ€åÿü': 'slaaw, choni?',
            'ÿ≥ŸàŸæÿßÿ≥': 'supas',
            'ÿ®€ï⁄ï€éÿ≤': 'ber√™z',
            'ÿ®€ï€åÿßŸÜ€å ÿ®ÿßÿ¥': 'beyan√Æ baash',
            'ÿ¥€ïŸà€å ÿ®ÿßÿ¥': 'shew√Æ baash',
            'ÿÆŸàÿßÿ™ ŸÑ€ï⁄Ø€ï⁄µ': 'xwat legell',
            'ŸÖŸÜ ŸÜÿßŸà€å ŸÖŸÜ ŸÜÿßÿ≥€ïÿ±€ï': 'min naw√Æ min naser e',
            '⁄Ü€ÜŸÜ ÿØ€ï⁄Ü€åÿ™': 'chon dechit',
            'ÿ≤€Üÿ± ÿ®ÿßÿ¥ ÿ®ŸàŸà': 'zor baash bu',
            'ÿ®€Ü €åÿßÿ±ŸÖ€ïÿ™€åÿ™': 'bo yarmetit'
        };
        
        // If exact match not found, try to generate phonetic
        if (phoneticMap[kurdishText]) {
            return phoneticMap[kurdishText];
        }
        
        // Generate basic phonetic for unknown text
        return this.generateBasicPhonetic(kurdishText);
    }

    generateBasicPhonetic(kurdishText) {
        // Basic phonetic rules for Kurdish Sorani
        const phoneticRules = {
            'ÿ≥': 's',
            '⁄µ': 'll',
            'ÿß': 'a',
            'Ÿà': 'w',
            '⁄Ü': 'ch',
            '€Ü': 'o',
            'ŸÜ': 'n',
            '€å': 'i',
            'ÿ≥': 's',
            'Ÿæ': 'p',
            'ÿ®': 'b',
            '€ï': 'e',
            'ÿ¥': 'sh',
            'Ÿà': 'w',
            '€å': 'i',
            'ÿ™': 't',
            'ÿ±': 'r',
            'ÿ≤': 'z',
            'ŸÖ': 'm',
            'ŸÜ': 'n',
            '⁄Ø': 'g',
            'ŸÑ': 'l',
            'ÿØ': 'd',
            '⁄©': 'k',
            'Ÿá': 'h',
            'ÿπ': '3',
            'ÿ∫': 'gh',
            'ŸÇ': 'q',
            'ŸÅ': 'f',
            'ÿ´': 'th',
            'ÿ≠': 'h',
            'ÿÆ': 'kh',
            'ÿ∞': 'dh',
            'ÿ∂': 'dh',
            'ÿ∑': 't',
            'ÿ∏': 'dh',
            'ÿµ': 's',
            'ÿ¨': 'j',
            'Ÿá': 'h'
        };
        
        let phonetic = '';
        for (let char of kurdishText) {
            if (phoneticRules[char]) {
                phonetic += phoneticRules[char];
            } else {
                phonetic += char;
            }
        }
        
        return phonetic;
    }

    showResult(text) {
        this.resultText.textContent = text;
        this.resultText.style.display = 'block';
        
        // Add animation classes
        this.resultText.classList.add('fade-in');
        
        // Add success animation if translation is successful
        if (text && !text.includes('error') && !text.includes('Error')) {
            this.resultText.classList.add('glow');
            setTimeout(() => {
                this.resultText.classList.remove('glow');
            }, 2000);
        }
        
        // Remove animation class after animation completes
        setTimeout(() => {
            this.resultText.classList.remove('fade-in');
        }, 500);
    }

    swapLanguages() {
        const temp = this.sourceLang.value;
        this.sourceLang.value = this.targetLang.value;
        this.targetLang.value = temp;
        this.saveSettings();
    }

    clearText() {
        this.sourceText.value = '';
        this.resultText.textContent = '';
    }

    async pasteText() {
        try {
            const text = await navigator.clipboard.readText();
            this.sourceText.value = text;
        } catch (error) {
            this.showResult('Unable to paste text. Please paste manually.');
        }
    }

    async copyResult() {
        const text = this.resultText.textContent;
        if (text) {
            try {
                await navigator.clipboard.writeText(text);
                this.copyBtn.textContent = 'Copied!';
                this.copyBtn.classList.add('glow');
                
                setTimeout(() => {
                    this.copyBtn.textContent = 'Copy';
                    this.copyBtn.classList.remove('glow');
                }, 2000);
            } catch (error) {
                this.showResult('Unable to copy text.');
                this.copyBtn.classList.add('shake');
                setTimeout(() => {
                    this.copyBtn.classList.remove('shake');
                }, 600);
            }
        }
    }

    speakText() {
        const text = this.resultText.textContent;
        if (text && 'speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = this.getLanguageCode(this.targetLang.value);
            speechSynthesis.speak(utterance);
        }
    }

    getLanguageCode(lang) {
        const codes = {
            'en': 'en-US',
            'ku-sorani': 'ku-IQ',
            'ku-kurmanji': 'ku-TR',
            'ar': 'ar-SA',
            'fa': 'fa-IR',
            'tr': 'tr-TR',
            'fr': 'fr-FR',
            'de': 'de-DE',
            'es': 'es-ES',
            'ru': 'ru-RU',
            'zh': 'zh-CN',
            'ja': 'ja-JP'
        };
        return codes[lang] || 'en-US';
    }

    async translatePage() {
        try {
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            if (!tab || !tab.id) {
                this.showResult('No active tab found.');
                return;
            }
            
            // Check if content script is loaded
            try {
                const response = await chrome.tabs.sendMessage(tab.id, { action: 'ping' });
                if (!response || response.error) {
                    throw new Error('Content script not responding');
                }
            } catch (error) {
                this.showResult('Content script not loaded. Please refresh the page and try again.');
                return;
            }
            
            // Send translation request
            try {
                await chrome.tabs.sendMessage(tab.id, { action: 'translatePage' });
                this.showResult('Page translation started. Check the page for results.');
            } catch (error) {
                this.showResult('Translation failed. Please try again.');
            }
        } catch (error) {
            console.error('Translate page error:', error);
            this.showResult('Unable to translate page. Please refresh and try again.');
        }
    }

    async translateSelection() {
        try {
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            if (!tab || !tab.id) {
                this.showResult('No active tab found.');
                return;
            }
            
            // Check if content script is loaded
            try {
                const response = await chrome.tabs.sendMessage(tab.id, { action: 'ping' });
                if (!response || response.error) {
                    throw new Error('Content script not responding');
                }
            } catch (error) {
                this.showResult('Content script not loaded. Please refresh the page and try again.');
                return;
            }
            
            // Get selected text
            try {
                const response = await chrome.tabs.sendMessage(tab.id, { action: 'getSelection' });
                if (response && response.text && response.text.trim()) {
                    this.sourceText.value = response.text;
                    this.translate();
                } else {
                    this.showResult('No text selected. Please select text on the page first.');
                }
            } catch (error) {
                this.showResult('Unable to get selection. Please select text manually.');
            }
        } catch (error) {
            console.error('Translate selection error:', error);
            this.showResult('Unable to get selection. Please select text manually.');
        }
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new ZimanTranslator();
});
